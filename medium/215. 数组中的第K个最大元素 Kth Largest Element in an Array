给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

你必须设计并实现时间复杂度为 O(n) 的算法解决此问题

Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

Can you solve it without sorting?

class Solution {
    public int findKthLargest(int[] nums, int k) {
         return quickSoart(nums, 0, nums.length -1, k);
    }

    private int quickSoart(int[] nums, int l, int r, int k){
        int index = randomParition(nums, l, r);
        if (index == k -1){
            return nums[index];
        } else {
            return index > k-1 ? quickSoart(nums, l, index -1 , k): quickSoart(nums, index +1, r, k);
        }
    }

    private int randomParition(int[] nums, int l, int r){
        int i = (int) (Math.random() * (r-l)) + l;
        swap(nums, i, r);
        return parition(nums, l, r);
    }

    private void swap (int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    private int parition(int[] nums, int l, int r){
        int pivot = nums[r];
        int rightmost = r;
        while(l <= r){
            while (l <= r && nums[l] > pivot){
                l ++;
            }
            while (l <= r && nums[r] <= pivot) {
                r --;
            }
            if(l <= r) {
                swap(nums, l, r);
            }
        }
        swap(nums, l, rightmost);
        return l;
    }

    
}